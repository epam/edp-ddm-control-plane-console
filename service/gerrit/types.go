package gerrit

import (
	"time"

	coreV1Api "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

type GerritProjectStatus struct {
	Value    string   `json:"value"`
	Branches []string `json:"branches"`
}

type GerritProjectSpec struct {
	OwnerName         string `json:"ownerName"`
	Name              string `json:"name"`
	Parent            string `json:"parent"`
	Description       string `json:"description"`
	PermissionsOnly   bool   `json:"permissionsOnly"`
	CreateEmptyCommit bool   `json:"createEmptyCommit"`
	SubmitType        string `json:"submitType"`
	Branches          string `json:"branches"`
	Owners            string `json:"owners"`
	RejectEmptyCommit string `json:"rejectEmptyCommit"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
type GerritProject struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GerritProjectSpec   `json:"spec,omitempty"`
	Status            GerritProjectStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
type GerritProjectList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GerritProject `json:"items"`
}

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// GerritSpec defines the desired state of Gerrit
// +k8s:openapi-gen=true

type GerritVolumes struct {
	Name         string `json:"name"`
	StorageClass string `json:"storage_class"`
	Capacity     string `json:"capacity"`
}

type GerritSpec struct {
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
	// Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file
	// Add custom validation using kubebuilder tags: https://book.kubebuilder.io/beyond_basics/generating_crd.html
	Image            string                           `json:"image"`
	Type             string                           `json:"type"`
	Version          string                           `json:"version"`
	ImagePullSecrets []coreV1Api.LocalObjectReference `json:"imagePullSecrets,omitempty"`
	Volumes          []GerritVolumes                  `json:"volumes,omitempty"`
	KeycloakSpec     KeycloakSpec                     `json:"keycloakSpec"`
	SshPort          int32                            `json:"sshPort,omitempty"`
}

// GerritStatus defines the observed state of Gerrit
// +k8s:openapi-gen=true
type GerritStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
	// Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file
	// Add custom validation using kubebuilder tags: https://book.kubebuilder.io/beyond_basics/generating_crd.html
	Available       bool      `json:"available,omitempty"`
	LastTimeUpdated time.Time `json:"lastTimeUpdated,omitempty"`
	Status          string    `json:"status,omitempty"`
	ExternalUrl     string    `json:"externalUrl"`
}

type KeycloakSpec struct {
	Enabled bool   `json:"enabled"`
	Url     string `json:"url,omitempty"`
	Realm   string `json:"realm,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Gerrit is the Schema for the gerrits API
// +k8s:openapi-gen=true
type Gerrit struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GerritSpec   `json:"spec,omitempty"`
	Status            GerritStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// GerritList contains a list of Gerrit
type GerritList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Gerrit `json:"items"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Gerrit) DeepCopyInto(out *Gerrit) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Gerrit.
func (in *Gerrit) DeepCopy() *Gerrit {
	if in == nil {
		return nil
	}
	out := new(Gerrit)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Gerrit) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritSpec) DeepCopyInto(out *GerritSpec) {
	*out = *in
	if in.ImagePullSecrets != nil {
		in, out := &in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]coreV1Api.LocalObjectReference, len(*in))
		copy(*out, *in)
	}
	if in.Volumes != nil {
		in, out := &in.Volumes, &out.Volumes
		*out = make([]GerritVolumes, len(*in))
		copy(*out, *in)
	}
	out.KeycloakSpec = in.KeycloakSpec
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritSpec.
func (in *GerritSpec) DeepCopy() *GerritSpec {
	if in == nil {
		return nil
	}
	out := new(GerritSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritStatus) DeepCopyInto(out *GerritStatus) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritStatus.
func (in *GerritStatus) DeepCopy() *GerritStatus {
	if in == nil {
		return nil
	}
	out := new(GerritStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritVolumes) DeepCopyInto(out *GerritVolumes) {
	*out = *in
	return
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeycloakSpec) DeepCopyInto(out *KeycloakSpec) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeycloakSpec.
func (in *KeycloakSpec) DeepCopy() *KeycloakSpec {
	if in == nil {
		return nil
	}
	out := new(KeycloakSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritVolumes.
func (in *GerritVolumes) DeepCopy() *GerritVolumes {
	if in == nil {
		return nil
	}
	out := new(GerritVolumes)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritProject) DeepCopyInto(out *GerritProject) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	out.Status = in.Status
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritProject.
func (in *GerritProject) DeepCopy() *GerritProject {
	if in == nil {
		return nil
	}
	out := new(GerritProject)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GerritProject) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritProjectList) DeepCopyInto(out *GerritProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GerritProject, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritProjectList.
func (in *GerritProjectList) DeepCopy() *GerritProjectList {
	if in == nil {
		return nil
	}
	out := new(GerritProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GerritProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritProjectSpec) DeepCopyInto(out *GerritProjectSpec) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritProjectSpec.
func (in *GerritProjectSpec) DeepCopy() *GerritProjectSpec {
	if in == nil {
		return nil
	}
	out := new(GerritProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritProjectStatus) DeepCopyInto(out *GerritProjectStatus) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritProjectStatus.
func (in *GerritProjectStatus) DeepCopy() *GerritProjectStatus {
	if in == nil {
		return nil
	}
	out := new(GerritProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GerritList) DeepCopyInto(out *GerritList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Gerrit, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GerritList.
func (in *GerritList) DeepCopy() *GerritList {
	if in == nil {
		return nil
	}
	out := new(GerritList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GerritList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
